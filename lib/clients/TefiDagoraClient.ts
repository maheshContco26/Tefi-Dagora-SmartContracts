/**
* This file was automatically generated by @octalmage/terra-cosmwasm-typescript-gen@0.1.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @octalmage/terra-cosmwasm-typescript-gen generate command to regenerate this file.
*/

import { LCDClient, Coins, Wallet, MsgExecuteContract, TxInfo, WaitTxBroadcastResult } from "@terra-money/terra.js";
import { ConnectedWallet } from "@terra-money/wallet-provider";
function isConnectedWallet(x: Wallet | ConnectedWallet): x is ConnectedWallet {
  return typeof (x as Wallet).key === "undefined";
};
async function waitForInclusionInBlock(lcd: LCDClient, txHash: string): Promise<TxInfo | undefined> {
  let res;
  for (let i = 0; i <= 50; i++) {
    try {
      res = await lcd.tx.txInfo(txHash);
    } catch (error) {
      // NOOP
    }
      
    if (res) {
      break;
    }
      
    await new Promise((resolve) => setTimeout(resolve, 500));
  }
      
  return res;
};
export type Addr = string;
export interface Comment {
  author: Addr;
  comment: string;
  comment_id: number;
  thread_id: number;
  [k: string]: unknown;
}
export interface CommentsResponse {
  entries: Comment[];
  [k: string]: unknown;
}
export type Uint128 = string;
export interface Config {
  admin_addr: Addr;
  comment_fee: Uint128;
  thread_fee: Uint128;
  [k: string]: unknown;
}
export type ExecuteMsg = {
  create_thread: {
    category: string;
    content: string;
    title: string;
    [k: string]: unknown;
  };
} | {
  update_thread: {
    content: string;
    id: number;
    title: string;
    [k: string]: unknown;
  };
} | {
  update_thread_content: {
    content: string;
    id: number;
    [k: string]: unknown;
  };
} | {
  update_thread_title: {
    id: number;
    title: string;
    [k: string]: unknown;
  };
} | {
  add_comment: {
    comment: string;
    thread_id: number;
    [k: string]: unknown;
  };
} | {
  update_comment: {
    comment: string;
    comment_id: number;
    [k: string]: unknown;
  };
} | {
  send: {
    address: Addr;
    amount: Uint128;
    [k: string]: unknown;
  };
} | {
  update_fees: {
    comment_fee?: Uint128 | null;
    thread_fee?: Uint128 | null;
    [k: string]: unknown;
  };
};
export interface InstantiateMsg {
  comment_fee?: Uint128 | null;
  thread_fee?: Uint128 | null;
  [k: string]: unknown;
}
export type QueryMsg = {
  get_thread_by_id: {
    id: number;
    [k: string]: unknown;
  };
} | {
  get_threads_by_category: {
    category: string;
    limit?: number | null;
    offset?: number | null;
    [k: string]: unknown;
  };
} | {
  get_threads_by_author: {
    author: Addr;
    limit?: number | null;
    offset?: number | null;
    [k: string]: unknown;
  };
} | {
  get_comment_by_id: {
    id: number;
    [k: string]: unknown;
  };
} | {
  get_comments_by_thread: {
    limit?: number | null;
    offset?: number | null;
    thread_id: number;
    [k: string]: unknown;
  };
} | {
  get_config: {
    [k: string]: unknown;
  };
};
export interface Thread {
  author: Addr;
  category: string;
  content: string;
  id: number;
  title: string;
  [k: string]: unknown;
}
export interface ThreadsResponse {
  entries: Thread[];
  [k: string]: unknown;
}
export interface TefiDagoraReadOnlyInterface {
  contractAddress: string;
  getThreadById: ({
    id
  }: {
    id: number;
  }) => Promise<ThreadByIdResponse>;
  getThreadsByCategory: ({
    category,
    limit,
    offset
  }: {
    category: string;
    limit?: number;
    offset?: number;
  }) => Promise<ThreadsByCategoryResponse>;
  getThreadsByAuthor: ({
    author,
    limit,
    offset
  }: {
    author: string;
    limit?: number;
    offset?: number;
  }) => Promise<ThreadsByAuthorResponse>;
  getCommentById: ({
    id
  }: {
    id: number;
  }) => Promise<CommentByIdResponse>;
  getCommentsByThread: ({
    limit,
    offset,
    threadId
  }: {
    limit?: number;
    offset?: number;
    threadId: number;
  }) => Promise<CommentsByThreadResponse>;
  getConfig: () => Promise<ConfigResponse>;
}
export class TefiDagoraQueryClient implements TefiDagoraReadOnlyInterface {
  client: LCDClient;
  contractAddress: string;

  constructor(client: LCDClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getThreadById = this.getThreadById.bind(this);
    this.getThreadsByCategory = this.getThreadsByCategory.bind(this);
    this.getThreadsByAuthor = this.getThreadsByAuthor.bind(this);
    this.getCommentById = this.getCommentById.bind(this);
    this.getCommentsByThread = this.getCommentsByThread.bind(this);
    this.getConfig = this.getConfig.bind(this);
  }

  getThreadById = async ({
    id
  }: {
    id: number;
  }): Promise<ThreadByIdResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      get_thread_by_id: {
        id
      }
    });
  };
  getThreadsByCategory = async ({
    category,
    limit,
    offset
  }: {
    category: string;
    limit?: number;
    offset?: number;
  }): Promise<ThreadsByCategoryResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      get_threads_by_category: {
        category,
        limit,
        offset
      }
    });
  };
  getThreadsByAuthor = async ({
    author,
    limit,
    offset
  }: {
    author: string;
    limit?: number;
    offset?: number;
  }): Promise<ThreadsByAuthorResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      get_threads_by_author: {
        author,
        limit,
        offset
      }
    });
  };
  getCommentById = async ({
    id
  }: {
    id: number;
  }): Promise<CommentByIdResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      get_comment_by_id: {
        id
      }
    });
  };
  getCommentsByThread = async ({
    limit,
    offset,
    threadId
  }: {
    limit?: number;
    offset?: number;
    threadId: number;
  }): Promise<CommentsByThreadResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      get_comments_by_thread: {
        limit,
        offset,
        thread_id: threadId
      }
    });
  };
  getConfig = async (): Promise<ConfigResponse> => {
    return this.client.wasm.contractQuery(this.contractAddress, {
      get_config: {}
    });
  };
}
export interface TefiDagoraInterface extends TefiDagoraReadOnlyInterface {
  contractAddress: string;
  createThread: ({
    category,
    content,
    title
  }: {
    category: string;
    content: string;
    title: string;
  }, funds?: Coins) => Promise<any>;
  updateThread: ({
    content,
    id,
    title
  }: {
    content: string;
    id: number;
    title: string;
  }, funds?: Coins) => Promise<any>;
  updateThreadContent: ({
    content,
    id
  }: {
    content: string;
    id: number;
  }, funds?: Coins) => Promise<any>;
  updateThreadTitle: ({
    id,
    title
  }: {
    id: number;
    title: string;
  }, funds?: Coins) => Promise<any>;
  addComment: ({
    comment,
    threadId
  }: {
    comment: string;
    threadId: number;
  }, funds?: Coins) => Promise<any>;
  updateComment: ({
    comment,
    commentId
  }: {
    comment: string;
    commentId: number;
  }, funds?: Coins) => Promise<any>;
  send: ({
    address,
    amount
  }: {
    address: string;
    amount: string;
  }, funds?: Coins) => Promise<any>;
  updateFees: ({
    commentFee,
    threadFee
  }: {
    commentFee?: Uint128;
    threadFee?: Uint128;
  }, funds?: Coins) => Promise<any>;
}
export class TefiDagoraClient extends TefiDagoraQueryClient implements TefiDagoraInterface {
  client: LCDClient;
  wallet: Wallet | ConnectedWallet;
  contractAddress: string;

  constructor(client: LCDClient, wallet: Wallet | ConnectedWallet, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.wallet = wallet;
    this.contractAddress = contractAddress;
    this.createThread = this.createThread.bind(this);
    this.updateThread = this.updateThread.bind(this);
    this.updateThreadContent = this.updateThreadContent.bind(this);
    this.updateThreadTitle = this.updateThreadTitle.bind(this);
    this.addComment = this.addComment.bind(this);
    this.updateComment = this.updateComment.bind(this);
    this.send = this.send.bind(this);
    this.updateFees = this.updateFees.bind(this);
  }

  createThread = async ({
    category,
    content,
    title
  }: {
    category: string;
    content: string;
    title: string;
  }, funds?: Coins): Promise<WaitTxBroadcastResult | TxInfo | undefined> => {
    const senderAddress = isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress;
    const execMsg = new MsgExecuteContract(senderAddress, this.contractAddress, {
      create_thread: {
        category,
        content,
        title
      }
    }, funds);

    if (isConnectedWallet(this.wallet)) {
      const tx = await this.wallet.post({
        msgs: [execMsg]
      });
      return waitForInclusionInBlock(this.client, tx.result.txhash);
    } else {
      const execTx = await this.wallet.createAndSignTx({
        msgs: [execMsg]
      });
      return this.client.tx.broadcast(execTx);
    }
  };
  updateThread = async ({
    content,
    id,
    title
  }: {
    content: string;
    id: number;
    title: string;
  }, funds?: Coins): Promise<WaitTxBroadcastResult | TxInfo | undefined> => {
    const senderAddress = isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress;
    const execMsg = new MsgExecuteContract(senderAddress, this.contractAddress, {
      update_thread: {
        content,
        id,
        title
      }
    }, funds);

    if (isConnectedWallet(this.wallet)) {
      const tx = await this.wallet.post({
        msgs: [execMsg]
      });
      return waitForInclusionInBlock(this.client, tx.result.txhash);
    } else {
      const execTx = await this.wallet.createAndSignTx({
        msgs: [execMsg]
      });
      return this.client.tx.broadcast(execTx);
    }
  };
  updateThreadContent = async ({
    content,
    id
  }: {
    content: string;
    id: number;
  }, funds?: Coins): Promise<WaitTxBroadcastResult | TxInfo | undefined> => {
    const senderAddress = isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress;
    const execMsg = new MsgExecuteContract(senderAddress, this.contractAddress, {
      update_thread_content: {
        content,
        id
      }
    }, funds);

    if (isConnectedWallet(this.wallet)) {
      const tx = await this.wallet.post({
        msgs: [execMsg]
      });
      return waitForInclusionInBlock(this.client, tx.result.txhash);
    } else {
      const execTx = await this.wallet.createAndSignTx({
        msgs: [execMsg]
      });
      return this.client.tx.broadcast(execTx);
    }
  };
  updateThreadTitle = async ({
    id,
    title
  }: {
    id: number;
    title: string;
  }, funds?: Coins): Promise<WaitTxBroadcastResult | TxInfo | undefined> => {
    const senderAddress = isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress;
    const execMsg = new MsgExecuteContract(senderAddress, this.contractAddress, {
      update_thread_title: {
        id,
        title
      }
    }, funds);

    if (isConnectedWallet(this.wallet)) {
      const tx = await this.wallet.post({
        msgs: [execMsg]
      });
      return waitForInclusionInBlock(this.client, tx.result.txhash);
    } else {
      const execTx = await this.wallet.createAndSignTx({
        msgs: [execMsg]
      });
      return this.client.tx.broadcast(execTx);
    }
  };
  addComment = async ({
    comment,
    threadId
  }: {
    comment: string;
    threadId: number;
  }, funds?: Coins): Promise<WaitTxBroadcastResult | TxInfo | undefined> => {
    const senderAddress = isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress;
    const execMsg = new MsgExecuteContract(senderAddress, this.contractAddress, {
      add_comment: {
        comment,
        thread_id: threadId
      }
    }, funds);

    if (isConnectedWallet(this.wallet)) {
      const tx = await this.wallet.post({
        msgs: [execMsg]
      });
      return waitForInclusionInBlock(this.client, tx.result.txhash);
    } else {
      const execTx = await this.wallet.createAndSignTx({
        msgs: [execMsg]
      });
      return this.client.tx.broadcast(execTx);
    }
  };
  updateComment = async ({
    comment,
    commentId
  }: {
    comment: string;
    commentId: number;
  }, funds?: Coins): Promise<WaitTxBroadcastResult | TxInfo | undefined> => {
    const senderAddress = isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress;
    const execMsg = new MsgExecuteContract(senderAddress, this.contractAddress, {
      update_comment: {
        comment,
        comment_id: commentId
      }
    }, funds);

    if (isConnectedWallet(this.wallet)) {
      const tx = await this.wallet.post({
        msgs: [execMsg]
      });
      return waitForInclusionInBlock(this.client, tx.result.txhash);
    } else {
      const execTx = await this.wallet.createAndSignTx({
        msgs: [execMsg]
      });
      return this.client.tx.broadcast(execTx);
    }
  };
  send = async ({
    address,
    amount
  }: {
    address: string;
    amount: string;
  }, funds?: Coins): Promise<WaitTxBroadcastResult | TxInfo | undefined> => {
    const senderAddress = isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress;
    const execMsg = new MsgExecuteContract(senderAddress, this.contractAddress, {
      send: {
        address,
        amount
      }
    }, funds);

    if (isConnectedWallet(this.wallet)) {
      const tx = await this.wallet.post({
        msgs: [execMsg]
      });
      return waitForInclusionInBlock(this.client, tx.result.txhash);
    } else {
      const execTx = await this.wallet.createAndSignTx({
        msgs: [execMsg]
      });
      return this.client.tx.broadcast(execTx);
    }
  };
  updateFees = async ({
    commentFee,
    threadFee
  }: {
    commentFee?: Uint128;
    threadFee?: Uint128;
  }, funds?: Coins): Promise<WaitTxBroadcastResult | TxInfo | undefined> => {
    const senderAddress = isConnectedWallet(this.wallet) ? this.wallet.walletAddress : this.wallet.key.accAddress;
    const execMsg = new MsgExecuteContract(senderAddress, this.contractAddress, {
      update_fees: {
        comment_fee: commentFee,
        thread_fee: threadFee
      }
    }, funds);

    if (isConnectedWallet(this.wallet)) {
      const tx = await this.wallet.post({
        msgs: [execMsg]
      });
      return waitForInclusionInBlock(this.client, tx.result.txhash);
    } else {
      const execTx = await this.wallet.createAndSignTx({
        msgs: [execMsg]
      });
      return this.client.tx.broadcast(execTx);
    }
  };
}